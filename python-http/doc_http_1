#! /usr/bin/python

* AF_INET: IPv4 protocols (both TCP and UDP)
* AF_INET6: IPv6 protocols (both TCP and UDP)
* AF_UNIX: UNIX domain protocols 

* SOCK_STREAM: a connection-oriented, TCP byte stream
* SOCK_DGRAM: UDP transferral of datagrams (self-contained IP packets that do not rely on client-server confirmation)
* SOCK_RAW: a raw socket
* SOCK_RDM: for reliable datagrams
* SOCK_SEQPACKET: sequential transfer of records over a connection 


---------------------------------

在有很多功能强大的http服务器，APACHE，IIS我们应该都很熟悉, 其实众多的http服务器都有个最基本的工作流程：
1.初始化工作环境，在固定端口（80）侦听外部请求
2.接收请求
3.建立连接
4.发送响应头部
5.发送响应内容
6.中断连接

---------------------------------

* 一个 Web 浏览器，例如 Firefox 或 Internet Explorer，用于请求一个特定的页面，并且以人类可读的方式显示从另一个应用程序那里收到的内容。
* 一个 Web 服务器，通常是在远程机器上，负责对页面请求作出响应，返回 HTML 编码的或类似的数据流。

评价一个 Web 服务器的重要指标有：
* 性能：对请求作出响应的速度有多快？
* 可伸缩性：当很多用户同时访问它时，服务器还能继续可靠地运行吗？
* 安全性：服务器是否只执行它应该执行的操作。它在认证用户和加密传输方面提供了怎样的支持？它的使用是否使附近的应用程序或主机变得更易受攻击？
* 可靠性：服务器的失效模式和故障发生率如何？
* 标准遵从性：服务器遵从相关的 RFC 吗？
* 灵活性：是否可以对服务器进行调优，以支持较重的请求负载、需要计算的动态页面或者代价不菲的认证等等？
* 平台需求：该服务器可用于哪些平台？它是否有特定的硬件需求？
* 易管理性：服务器是否易于设置和维护？它是否与日志记录、审计、成本计算等组织标准兼容？

---------------------------------

Python 一直广泛支持各种基本的网际协议，再加上具有良好的可读性并且易于维护，这些使它成了动态编程的坚实基础。这里，我们列出了 Python 的一些对 Web 服务开发很有用的核心功能程序。这里列出的每一个功能程序都是随 Python 一起提供的，不需要再去下载或安装。

* HTTP：该核心库包含成熟的 HTTP 1.1 服务器实现，同时包含文件和 CGI 服务器。为您自己定制这些东西非常容易，它们早已经帮助您使 Web 服务任务自动化了。自然也有进行 HTTP 请求的工具，包括低级 httplib （它使您可以控制 HTTP 请求的各个方面）和快速但不太正规的 urllib （它只用一个 URL 从适当的位置获得数据）。请注意，Python 还提供 SSL 支持，这允许通过 HTTPs 来保护 Web 站点的安全。

* URL 的解析和构造：有一些模块用于把更自然的 Python 数据结构组成 URL，或者把 URL 分解为 Python 数据结构。这些模块使得 Web 服务很容易处理带请求参数和片段等内容的 URL。

* CGI：有一整套工具用于解释 CGI 请求，使大家可以很容易地编写有效的 CGI 处理程序。

* HTML（和 SGML）：Python 附带用于解析 HTML 及其母语 SGML 的模块。

* XML：在 XML 的简短历史上，Python 一直都大力支持 XML。在 Python 的标准库中有几个 XML 分析器、DOM 和 SAX 库。

* FTP、SMTP、NNTP、POP、IMAP 等等：这个库包含其它这些重要网际协议的很多客户机模块。每个模块都提供对会话细节的非常适当的级别的控制，并提供用于把数据格式解析为更 Python 化的结构的令人印象深刻的工具箱。使用它们把 Web 服务与其它因特网应用程序关联起来很方便；例如，它们通过电子邮件提供事件通知。

* 低级套接字：当您确实想亲自进行网络编程时，您可以不用上面提到的模块所提供的方便，而是随心所欲地在网络上玩那些位和字节。Python 库提供客户机和服务器套接字编程模块。

浏览器控件：Python 提供了一个整洁的模块 webbrowser ，它用来启动和控制各种 Web 浏览器（包括 Netscape、Internet Explorer 和 Konqueror）。这是一个有用的工具，用于把传统的组件与内部网或类似环境内的 Web 服务关联起来。

________________________________


下面是本文中使用的一些行话的简短定义。

* 通用对象请求代理体系结构 （Common Object Request Broker Architecture，CORBA）：Object Management Group 的面向对象组件的标准。
* 分布式组件对象模型（Distributed Component Object Model，DCOM）：Microsoft 的面向对象组件的标准。
* Enterprise JavaBeans（EJB）：一个基于 Java 的组件开发标准。
* 简单对象访问协议（Simple Object Access protocol，SOAP）：一种用于编写消息的规范，使用 HTTP 和 SMTP 等协议可以将遵守该规范的消息发送到 XML 格式的远程对象。
* 统一描述、发现和集成（Universal Description, Discovery and Integration，UDDI）：一个基于 Web 的服务的目录的标准。
* Web 文档编制和版本控制（Web Document Authoring and Versioning，WebDAV）：修改和管理远程 Web 服务器上文档的标准。
* 文档对象模型（Document Object Model，DOM）：对 XML 和 HTML 文档进行面向对象的访问的标准。
* XML 的简单 API（Simple API for XML，SAX）：使用基于事件的模型访问 XML 文档的规范。
* 安全套接字层（Secure Sockets Layer，SSL）：对因特网和相似的网络上的通信进行加密的标准。
* Web 分布式数据交换（Web Distributed Data Exchange，WDDX）：将程序数据作为高度结构化的 XML 进行交换的模式。


* XML 是一种用于 Web 服务的非常流行的数据格式。它的高度结构化和可扩展性、广泛的支持以及各种相关的标准使它成了一种用于编写服务的子组件之间的请求、响应和通信的流行格式。我们已经讨论过了 Python 的内置 XML 功能程序。还有许多第三方的 XML 功能程序。Python XML SIG 开发了 PyXML 包，这个包添加了各种解析器、DOM 和 SAX 工具、用于 WDDX 和 XML-RPC 的数据组织工具和形形色色的 XML 处理工具。还有 Sean McGrath 的 Pyxie，它用原始的方法处理 XML。

* 4Suite（由本文的作者共同开发的）中提供了一系列附加的 XML 工具，这些工具是以 PyXML 为基础构建的，并添加了许多与 XML 相关的功能程序，包括 DOM（瞬时的和持久的）、XPath、XPointer、XSLT、XLink、RDF 和 XInclude。只需使用这些功能程序，就可以开发 Web 服务的许多方面，并且需要的定制代码极少。特别是 RDF，它是最有发展前途的一种用来描述必须为 Web 服务编入索引的关系和数据的技术。Python 在 4Suite 和 James Tauber 的 Redfoot 框架中都有 RDF 支持。

* SOAP 当然是 Web 服务最心爱的协议。SOAP 是一个协议，用于使用嵌入 HTML、SMTP 或其它较低级协议中的、严格指定的 XML 把消息发送到远程系统。Pythonware 的 soaplib 为 Python 提供了基本的 SOAP 和 XML-RPC 支持。目前 soaplib 和其它流行的 SOAP 实现之间有一些互操作性问题，但 soaplib 的一个新发行版即将出现，它承诺会改善互操作性并提供更广泛的 SOAP 支持。还可以从 Ken MacLeo 的 Scarab 项目得到一些比较粗糙的、陈旧的 SOAP 代码。

* Fourthought 的 4Suite Server（也是由本文作者共同开发的）是一个基于 4Suite 的 XML 数据服务器，它为存储、管理、传输和处理 XML 提供“取出即可用”的支持。它支持使用 CORBA、HTTP 和非常基本的 SOAP 进行通信，并且不久将添加更多的协议，比如 WebDAV 和 SMTP。

* Digital Creations 开发了 Zope，一个流行的基于 Python 的应用程序服务器；Zope 提供一般的对象服务、基于模板的 HTML 输出和 WebDAV。XML 支持仍在开发中。

* Chuck Esterbrook 的 Webware 是一套用于在 Python 中开发基于 Web 的应用程序的工具。它与 Java servlet、JSP 之类的工具很相似。

最后，由于大多数用户仍然使用只支持 HTML 的 Web 浏览器访问 Web，能够处理 HTML 就成了大多数 Web 服务的一个重要部分。DOM 有一些构建 HTML 文档的工具，而 4Suite 可以从 DOM 或 XSLT 输出 HTML。如果您更倾向于基于模板的方法，那么可以使用 Robin Friedrich 的非常成熟的 HTMLgen 模块。

----------------------------------


Web 工作原理
Web 是一种基于客户机/服务器的体系结构,客户机向服务器发送请求,要求执行某项任务,而服务器执行此项任务,并向客户机返回响应。
Web 客户程序叫做浏览器(Browser),而浏览器程序基本上都是标准化的。因此,Web 体系结构可以称为浏览器/服务器结构。
在浏览器里输入一个静态网页网址后,就向服务器端提出了一个浏览网页的请求。
服务器端接到请求后,就会找到用户要浏览的静态网页文件,然后发送给用户。这种方式基于静态网页的工作原理。
动态网页的工作原理与静态网页有很大的不同。当用户在浏览器里输入一个动态网页网址后,就向服务器端提出了一个浏览动态网页的请求。服务器端接到请求后,首先会找到用户要浏览的动态网页文件,然后就执行网页文件中的程序代码,将含有程序代码的动态网页转化为标准的静态网页,然后将静态网页发送给用户。


统一资源定位器 URL
用户在 Internet 网上寻找分布在全球的 WWW 的信息,必须有一种说明该信息存放在哪台计算机的哪个路径下的定位信息。
统一资源定位器 URL(Uniform Resource Locator)就是用来确定某信息具体位置的方法。
URL 通过定义资源位置的抽象标识来定位网络资源,其格式如下:
       <信息服务类型>://<信息资源地址>/<文件路径>
<信息服务类型>是指 Internet 的协议名包括:
    ftp(文件传输服务)
    http(超文本传输服务) 
    gopher(Gopher 服务) 
    mail 电子邮件地址) 
    telnet 远程登录服务)
    news(提供网络新闻服务)
<信息资源地址>指定一个网络主机的域名或 IP 地址。在有些情况下,主机域名后还要加上端口号,域名与端口号之间用冒号(:)隔开。
这里的端口是操作系统用来辨认特定信息服务的软件端口。一般情况下,服务器程序采用标准的保留端口号,因此,用户在 URL中可以省略。

代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。　代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。

-------------------------------------


静态网页:
在客户端进行请求的时候，假若请求的是一个静态的网页的话，那么这个网页请求到了WEB服务器以后，服务器就会在本身安装的机器的硬盘上寻找相关的网页，然后进行返回.

动态网页:
如果请求的是一个包含动态语言代码的网页，那么服务器接收到以后，就会接着传送给同时安装在这个机器上的应用程序服务器，在这里也就是我们说的PHP处理程序。
PHP 处理程序，会理解并解释这些代码的含义。然后对他们处理，然后把这些代码删除了，并且用自己解释了的东西来代替他们。这个时候原先来的动态网页的请求，返回的时候仍然是一个很单纯的静态HTML网页。   这里也说明了：即使是动态的网站，在用户端也是看不到动态语言的代码的。一定程度上的保护作用。

数据库:
应用程序服务器就这么解释了那些实现动态网站功能的代码。那么那些内容是那里来的呢？当然是数据库了~~
所以在WEB服务器端有了PHP应用处理程序，还有一个MYSQL SERVER, 但是应用处理程序和DB SERVER连接的时候是通过中间的一个数据库驱动程序。这个驱动程序，接收PHP应用程序从网页请求中辨认出来的那些代码，然后执行那些代码所代表的功能 。


-----------------------------------

PHP的工作原理
PHP的所有应用程序都是通过WEB服务器(如IIS或Apache)和PHP引擎程序解释执行完成的，工作过程：
(1)当用户在浏览器地址中输入要访问的PHP页面文件名，然后回车就会触发这个PHP请求，并将请求传送化支持PHP的WEB服务器。
(2)WEB服务器接受这个请求，并根据其后缀进行判断如果是一个PHP请求，WEB服务器从硬盘或内存中取出用户要访问的PHP应用程序，并将其发送给 PHP引擎程序。
(3)PHP引擎程序将会对WEB服务器传送过来的文件从头到尾进行扫描并根据命令从后台读取，处理数据，并动态地生成相应的HTML页面。
(4)PHP引擎将生成HTML页面返回给WEB服务器。WEB服务器再将HTML页面返回给客户端浏览器。
简言之：apache是WEB服务器，它可以解析php语言。

Apache的工作原理
Web系统是客户端/服务器式的，所以应该有服务器程序和客户端程序两部分。
常用的服务器程序是Apache；
常用的客户端程序是浏览器（如IE、 Netscape、Mozilla）。
我们可以在浏览器的地址栏内输入统一资源定位地址（URL）来访问Web页面。
Web最基本的概念是超文本 （Hypertext）。它使得文本不再是传统的书页式文本，而是可以在阅读过程中从一个页面位置跳转到另一个页面位置。用来书写Web页面的语言称为超 文本标记语言，即HTML。WWW服务遵从HTTP协议，默认的TCP/IP端口是80，客户端与服务器的通信过程简述如下：
（1）客户端（浏览器）和Web服务器建立TCP连接，连接建立以后，向Web服务器发出访问请求（如get）。根据HTTP协议，该请求中包含了客户端 的IP地址、浏览器的类型和请求的URL等一系列信息。
（2）Web服务器收到请求后，将客户端要求的页面内容返回到客户端。如果出现错误，那么返回错误代码。
（3）断开与远端Web服务器的连接。
下面是一个客户端发送给Web服务器请求的数据包的内容：
       GET /engineer/ideal/list.htm HTTP/1.1
       Accept: image/gif, image/x-xbitmap,
       image/jpeg, image/pjpeg,
       application/vnd.ms-powerpoint, application/vnd.ms-excel,
       application/msword, */*
       Referer: http://www.linuxar.com.cn/engineer/ideal/
       Accept-Language: zh-cn
       Accept-Encoding: gzip, deflate
       User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)
       Host: www.linuxar.com.cn
       Connection: Keep-Alive  

从代码中可以看到，在客户端的请求里包含了很多有用的信息，如客户端类型等。Web服务器会将请求的Web页内容发送返回给客户端。 
HTTP/1.1说明：HTTP/1.1（超文本链接协议1.1版本）是HTTP协议的最新版本。HTTP协议是运行在TCP/IP协议组上的万维网应用 协议。HTTP/1.1提供了比前一版本更快的访问网站速度，同时针对网络资源进行优化，降低了网络流量。HTTP/1.1由互联网工程任务组开发。现在 大部分服务器和网站都支持HTTP/1.1协议。

下面是一些HTTP/1.1能够加快网页访问速度的原因。
（1）以往的HTTP协议每次访问应用程序时，都会进行创立及撤销链接的步骤。HTTP/1.1在首次访问网站时建立持久链接，将多个请求批量或通过管道 发送到输出缓冲区内。TCP协议允许将多个来自IP层的数据包请求或回复命令集中到一个TCP段中。因此减少了反复建立链接所需的时间，同时由于没有了不 必要的申请链接数据包，也降低了网络流量。由于将命令通过管道输送，大大提高了TCP段的效率。总之，网络流量降低了，性能提高了。
（2）当支持HTTP/1.1的浏览器发现网页是未压缩网页时，会将网页进行压缩后进行传输，这样可以节约更多流量空间，不过由于网页中的图片文件一般都 已经被压缩过，因此，这种压缩对图片多的网页不太有效。除持久链接及其他改进后的性能之外，HTTP/1.1还允许多个域名共享同一IP地址。这简化了网 络服务器对虚拟主机数目管理的处理量。


---------------------------------------

目前各种服务器HTTP Server对PHP的支持一共有三种：

a.通过HTTPServer内置的模块来实现，
例如Apache的mod_php5，类似的Apache内置的mod_perl可以对perl支持；

b.通过CGI来实现，这个就好比之前perl的CGI，该种方式的缺点是性能差，因为每次服务器遇到这些脚本都需要重新启动脚本解析器来执行脚本然后将结果返回给服务器；另一方面就是不太安全；该方面几乎很少使用了。

c. 最新出现一种叫做FastCGI。所谓FastCGI就是对CGI的改进。它一般采用C/S结构，一般脚本处理器会启动一个或者多个daemon进程，每次HTTPServer遇到脚本的时候，直接交付给FastCGI的进程来执行，然后将得到的结果(通常为html)返回给浏览器。该种方法的问题存在一个小问题是当遇到大流量的频繁请求的话，脚本处理器的daemon进程可能会超负荷从而变得很慢，甚至发生内存泄漏；但是比较起Apache的内置模块的方式的优点是由于Server和脚本解析器完全分开各负其责，因此服务器不再臃肿，可以专心地进行静态文件响应或者将动态脚本解析器的结果返回给用户客户端。所以比较起Apache的内置模块方式，有时候性能要提高很多。有人测试可能会达到 Apache+mod_php的5~10倍。

目前在HTTPServer这块基本可以看到有三种stack比较流行：
    > Apache+mod_php5
    > lighttp+spawn-fcgi
    > nginx+PHP-FPM

三者后两者性能可能稍优，但是Apache由于有丰富的模块和功能，目前来说仍旧是老大。有人测试nginx+PHP-FPM在高并发情况下可能会达到Apache+mod_php5的5~10倍，现在nginx+PHP-FPM使用的人越来越多。


---------------------------------------


HTTP消息格式
    HTTP规范1.0[RPcl945]和1.1[RFC 2616]定义了HTTP消息的格式。HTTP消息分为请求消息和响应稍息两类。下面我们分别进行介绍。

HTTP请求消息
    下面是一个典型的HTTP请求消息:
    　　GET /somedir/page.html H7TP/1.1
    　　Host:www.yesky.com
    　　Connection:close
    　　User-agent:Mozilla/4.0
    　　Accept-language:zh-cn
    　　(额外的回车符和换行符)

首先，这个消息是用普通的ASCII文本书写的。其次，这个消息共有5行(每行以一个回车符和一个换行符结束)，最后一行后面还有额外的一个回车特和换行符。当然，一个请求消息可以不止这么多行，也可以仅仅只有一行。该请求消息的第一行称为请求行(request line)，后续各行都称为头部行(header)。
请求行有3个宁段:方法字段、URL字段、HTTP版本宇段。
    方法字段有若干个值可供选择，包括 GET、POST和HEAD。HTTP请求消息绝大多数使用GET方法，这是浏览器用来请求对象的方法，
    所请求的对象就在URL字段中标识。本例表明浏览器在请求对象/somedir/page.html。
    版本字段是不言自明的;本例中浏览器实现的是HTTP/1.1版本。


HTTP响应消息
　　下面是一个典型的HTTP响应消息:
    　　HTTP/1.1 200 0K
    　　Connectlon:close
    　　Date: Thu, 13 Oct 2005 03:17:33 GMT
    　　Server: Apache/2.0.54 (Unix)
    　　Last—Nodified:Mon,22 Jun 1998 09;23;24 GMT
    　　Content—Length:682l
    　　Content—Type:text/html

    　　(数据 数据 数据 数据 数据…………)

这个响应消息分为3部分：1个起始的状态行(status line)，6个头部行、1个包含所请求对象本身的附属体。
状态行有3个字段:协议版本字段、状态码字段、原因短语字段。
    本例的状态行表明，服务器使用HTTP/1.1版本，
    响应过程完全正常(也就是说服务器找到了所请求的对象，并正在发送)。


    Date: 头部行指出服务器创建并发送本响应消息的日期和时间。注意，这并不是对象本身的创建时间或最后修改时间，而是服务器把该对象从其文件系统中取出，插入响应消息中发送出去的时间。
    Server:头部行指出本消息是由Apache服务器产生的;它与HTTP请求消息中的User-agent:头部行类似。 
    Last—Nodified:头部行指出对象本身的创建或最后修改日期或时间。Last—Nodified:头部对于对象的高速缓存至关重要，且不论这种高速缓存是发生在本地客户主机上还是发生在网络高速缓存服务器主机(也就是代理服务器主机)上。
    Content—Length:头部行指出所发送对象的字节数。
    Content—Type:头部行指出包含在附属体中的对象是HTML文本。对象的类型是由Content—Type:头部而不是由文件扩展名正式指出的。

　　注意，如果服务器收到一个HTTP/1.0的请求，那么它即使是一个HTTP/1.1服务器，也不会使用持久连接。相反，这样的HTTP/1.1服务器会在发出所请求的对象后关闭TCP连接。这么做是必要的，因为HTTP/1.0客户期待服务器马上关闭连接。

    200 0K;请求成功，所请求信息在响应消息中返回。
　　301 Moved Permanently:所请求的对象己永久性迁移;新的URL在本响应消息的Location:头部指出。客户软件会自动请求这个新的URL。
　　400 Bad Request;表示服务器无法理解相应请求的普通错误的状态码
　　404 Not Found:服务器上不存在所请求的文档。
　　HTTP Version Not Support:服务器不支持所请求的HTTP协议版本。


-------------------------------------

身份认证和cookie

我们已经知道HTTP服务器是无状态的。这样的处理可以简化服务器程序的设计，以便开发出更高性能的Web服务器软件。然而，一个Web站点往往有标识其用户的需求，因为其web服务器可能希望限制用户的访问，也可能想要根据用户的身份来提供内容。HTTP提供了两种帮助服务器标识用户的机制: 身份认证和cookle。

身份认证许多web站点要求用户提供一个用户名—口令对才能访问存放在其服务器中的文档。这种要求称为身份认证 (authentication)。HTTP提供特殊的状态码和头部来帮助Web站点执行身份认证。我们通过查看一个例子来领会这些特殊的状态码和头部如何工作。假设有—个客户在请求来自某个服务器的一个对象，而该服务器要求用户授予权限。

客户首先发送一个不合特殊头部的普通请求消息。服务器以空的附属体和一个“401Authorization Required”状态码作为响应。服务器还在这个响应消息中包含“个WWW-Authenticate:头部，说明具体如何执行身份认证。这个头部的典型值是指出用户需要提供一个用户名—口令对。

客户收到这个响应消息后提示用户输入用户名和口令，然后重新发送请求消息。这一回客户在请求消息中包含了一个Authorization:头部，其中包含有用户输入的用户名和口令。

取得第一个对象后，客户在同为请求该服务器上对象的后续请求中继续发送这个用户名—口令对。这个做法一般将持续到用户关闭浏览器为止。在浏览器未被关闭之前，这个用户名—口令对是高速缓存着的，因此浏览器不会每请求一个对象就提示用户输入一次用户名和口令。通过上述方式，要求用户授权的Web站点就能标识出每个请求的用户了。

我们需要知道，HTTP执行的是一种相当脆弱的身份认证方式，不难攻破。现代有很多更为安全的认证方式，我们会在以后介绍。

cookie是一种可让Web站点用来跟踪用户的候选机制，定义在RFC 2109中。有些Web站点使用cookie，其他Web站点则不用。下面查看一个例子。假设一个客户首次联系一个使用cookie的web站点。服务器会在其响应中包含一个Set—Cookie:头部。该头部的值可以是一个由Web服务器产生的客户标识数.例如:

　　Set-Cookie:1678453

客户收到这个响应消息，看到其中的Set-Cookie:头部和标识数后，会在存放在客户主机中的某个特殊的cookie文件中添加一行。这一行一般包含服务器主机的主机名和这个与用户关联的标识数。在一段时间(如一个星期)之后请求同一个服务器时，由同一个用户启动的新客户会在请求消息中包含一个cookie头部，其值为早先由该服务器产生的标识数，例如:Cookie:1678453

在这种方式中，服务器并不知道提出请求的用户的用户名，但是它确实知道该用户与一个星期前提出请求的用户是同一个。
Web服务器有多个使用coohe的目的:
　如果服务器要求身份认证，但又不想在同一用户每次访问本Web站点时都麻烦他输入用户名和口令，那么可以设置一个cookie。
　如果服务器想要记住用户的偏好，以便在他们后续访问期间有目的地提供广告，那么可以设置一个cookie。
　如果web站点提供购物服务，那么服务器可以使用cookie跟踪用户购买的物品，就是建立一个虚拟的购物车。
需指出的是，cookie不适用于会从不同主机访问同一web站点的游动用户。这种情况下，该web站点会把同一个用户在不同主机上的使用看成是由新的用户执行的。


---------------------------------


带条件的GET

Web高速缓存技术通过就近存取先前取得的对象来降低对象检索延迟，减少因特网上的web流量。Web的高速缓存既可以驻留在客户主机中，也可以驻留在中间网络高速缓存服务器主机中。我们将在稍后讨论网络高速缓存，这里只关注客户的高速缓存。

Web高速缓存在降低用户可感知的响应时间的同时，却引入了一个新的问题——高速缓存中存放的对象的拷贝可能是过期的。换句话说，存放在web 服务器中的对象可能己在客户高速缓存下它的一个拷贝之后被修改了。幸运的是，HTTP提供一个专门的机制，使得在允许客户进行高速缓存的同时，仍确保传递给浏览器的所有对象都是最新的。这个机制称为带条件的0ET(conditional GET)。满足条件(1)使用GET方法和(2)包含If-Modified-S1nce:头部的HTTP请求消息就是所谓的带条件的Get消息。

我们通过查看一个例子来说明带条件的GET如何工作，向服务器请求一个尚未高速缓存的对象:
　GET /fruit/kiwi.gif HTTP/1.0
　User—agent: Mozilla/4.0

接着，web服务器把带这个对象的一个响应消息发送给客户:
　HTTP/1.0 200 OK
　Date: Thu, 13 Oct 2005 05:33:47 GMT
　Server: Apache/2.0.54 (Unix)
　Last-Modified:Thu, 13 Oct 2005 02:32:47 GMT
　Content-Type:image/gif

　(数据 数据 数据 数据 数据……)

客户把这个对象显示给用户，同时把它保存在自己的本地高速缓存中客户还随该对象本身高速缓存最后修改日期与时间。一个星期之后，同一个用户请求同一个对象，而该对象仍然存放在高速缓存中。既然web服务器中的该对象有可能已在最近一个星期被修改过，于是浏览器发出一个带条件的GET消息，执行判定高速缓存的对象拷贝是否为最新的检查;
　GET /fruit/kiwi.gif HTTP/1.0
　User—agent: Mozilla/4.0
　If—Modlfied—Since:Thu, 13 Oct 2005 02:32:47 GMT

其中，If—Modlfied—Since:头部的值就等于一个星期前由服务器发送的Last-Modified:头部的值。这个带条件的 GET消息告知服务器，只有在该对象自所指定的时间以来被修改了的前提下才发送它。假设该对象在这段时间内未曾被修改过，那么服务器将发送一个附属体为空的响应消息给客户;
　HTTP/1.0 304 Not Modified
　Date: Thu, 20 Oct 2005 05:33:47 GMT
　Server: Apache/2.0.54 (Unix)

我们看到，web服务器仍然发送——个响应消息作为带条件的GET消息的响应，不过其中不包含所请求的对象。包含该对象只会浪费带宽，并延长用户可感知的响应时间，特别是在该对象很大的时候。注意，这个响应消息的状态为“304 Not Modified”，它告知客户可以放心使用所请求对象的高速缓存版本。


---------------------------------

web高通缓存服务器

　　web高速缓存服务器(Web cache)是具有高速缓存功能的web代理服务器，它们在代表客户执行HTTP请求的问时，在自己的硬盘空间中保存近来请求到的对象的一个拷贝。如下图所示，用户首先把他们的浏览器配置成所有的HTTP请求都定向到web高速缓存服务器。。这样配置过的浏览器以后产生的每一个请求首先到达的将是Web高速缓存服务器。下面就以浏览器请求对象http://www.chinabyte.com/例，具体说明其过程。
Web缓存服务器工作原理

　　浏览器建立一个到Web高速缓存服务器的TCP连接，然后通过该连接向这个web高速缓存服务器发出一个访问所指对象的HTTP请求。

　　Web高速缓存服务器查看本地是否存有该对象的一个拷贝。如果有的话，它就把该对象包含在一个HTTP响应消息中发送给客户浏览器。

　　如果web高速缓存服务器找不到该对象的本地拷贝，它就建立一个到目标服务器即　　www.chinabyte.com的TCP连接。然后通过该连接发出一个访问所指对象的HTTP请求。目标服务器接收到这个请求后，把所请求的对象包含在一个HTTP响应消息中发送给Web高速缓存服务器。

　　web高速缓存服务器接收到这个对象后，在本地存放一个它的拷贝，再通过与客户浏览器之间的已有连接，把它的另一个拷贝包含在一个HTTP响应消息中发送给客户浏览器。

注意，web高速缓存服务器同时扮演服务器和客户两个角色。就从浏览器接收请求和往浏览器发送响应而言，它是服务器。就往目标服务器发送请求和从目标服务器接收响应而言，它是客户。

为什么要增添Web高速缓存服务器?它有哪些优势呢?在因特网中广泛地部署Web高速缓存服务器至少有3个理由。

首先，web高速缓存服务器可以充分地缩短客户请求的响应时间，特别是在客户与目标服务器之间的瓶颈带宽比它与高速缓存服务器之间的瓶颈带宽小得多的时候。如果在客户和高速缓存服务器之间存在一个高速连接(实际情况也通常是这样)，而且高速缓存服务器上存有所请求的对象，那么它将迅速地把该对象递送给客户。

其次，web高速缓存服务器可以充分地降低相应机构在因特网访问链路上的流量(后面会有相应的示例)。这样降低流量后，该机构(譬如说公司或大学)就不必过快地升级带宽，从而节省了费用。另外，web高速缓存服务器可以显著降低因特网的总体Web流量，从而改善所有应用的性能。

第三，在因特网的机构、地区、国家等层次上密布web高速缓存服务器主机可提供一个用于迅速散布内容的基础设施，即使是在低速访问链路之后的低速服务器主机上运行其Web站点的内容供应商也大受稗益。如果这些资源不足的内容供应商突然有受欢迎的内容待散布，那么这些内容将会在较短时间内拷贝到大量的高速缓存服务器中，从而满足用户的强烈需求



